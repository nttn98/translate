<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vietnamese to English Translator</title>
    <link rel="stylesheet" href="/static/style.css" />
  </head>

  <body>
    <div class="container">
      <h1>Vietnamese ‚Üí English Translator</h1>

      <div class="status-bar" id="status">Ready</div>

      <!-- INPUT -->
      <div class="section">
        <div class="section-header">
          <span class="section-title">Vietnamese Input</span>
          <div style="display: flex; gap: 8px">
            <button
              class="btn btn-primary"
              id="voiceBtn"
              onclick="toggleVoiceInput()"
            >
              üé§ Start Listening
            </button>
          </div>
        </div>

        <textarea
          id="inputText"
          placeholder="Type Vietnamese here..."
        ></textarea>
      </div>

      <!-- DETECTED SPEECH -->
      <div class="section">
        <div class="section-header">
          <span class="section-title">Detected Vietnamese (from mic)</span>
        </div>
        <div class="box" id="detectedText">‚Äî</div>
      </div>

      <!-- OUTPUT -->
      <div class="output-section">
        <div class="section-header">
          <span class="section-title">English Translation</span>
        </div>
        <div class="box" id="outputText">Translation will appear here...</div>

        <div class="button-group">
          <button class="btn btn-success" id="speakBtn" onclick="handleSpeak()">
            üîä Speak
          </button>
          <button class="btn btn-danger" onclick="handleStop()">‚èπÔ∏è Stop</button>
        </div>
      </div>

      <!-- SETTINGS -->
      <div class="settings">
        <h3>Settings</h3>
        <div class="setting-item">
          <label>Speech Speed: <span id="speedValue">1.0x</span></label>
          <input
            type="range"
            id="speedSlider"
            min="0.5"
            max="2"
            step="0.1"
            value="1.0"
            oninput="updateSpeed(this.value)"
          />
        </div>

        <label class="checkbox-label">
          <input type="checkbox" id="autoSpeak" checked /> Auto-speak after
          translation
        </label>

        <label class="checkbox-label">
          <input type="checkbox" id="continuous" checked /> Continuous mode
          (only new text)
        </label>
      </div>
    </div>

    <script>
      let recognition = null;
      let isListening = false;
      let isFromVoice = false;

      // STT state
      let fullVoiceTranscript = "";
      let processedVoiceTranscript = "";
      let voiceSilenceTimer = null; // 1s im l·∫∑ng

      // TTS state: ch·ªâ ƒë·ªçc t·ª´ng chunk, kh√¥ng c·ªông d·ªìn ƒë·ªÉ diff n·ªØa
      let lastTranslation = ""; // ƒëo·∫°n ti·∫øng Anh m·ªõi nh·∫•t (chunk cu·ªëi c√πng)

      // Typing state: ƒë·ªÉ l·∫•y ph·∫ßn Vietnamese m·ªõi th√™m (suffix)
      let prevInputVi = "";

      // debounce typing
      let typingTimer = null;

      function updateStatus(s) {
        document.getElementById("status").textContent = s;
      }

      function updateSpeed(v) {
        document.getElementById("speedValue").textContent =
          parseFloat(v).toFixed(1) + "x";
      }

      function isEnglishSentence(text) {
        const t = text.trim();
        if (!t) return false;
        const letters = t.match(/[A-Za-z]/g) || [];
        const hasViet = /[√Ä-·ª¥√†-·ªµƒÇƒÉ√Ç√¢√ä√™√î√¥∆†∆°∆Ø∆∞ƒêƒë]/.test(t);
        return letters.length >= 3 && !hasViet;
      }

      // l·∫•y ƒë·ªô d√†i prefix chung gi·ªØa 2 chu·ªói (d√πng cho typing)
      function longestCommonPrefixLen(a, b) {
        const max = Math.min(a.length, b.length);
        let i = 0;
        while (i < max && a[i] === b[i]) i++;
        return i;
      }

      // ------------- TTS: ch·ªâ ƒë·ªçc ƒë√∫ng ƒëo·∫°n text ƒë∆∞a v√†o, kh√¥ng t√°i s·ª≠ d·ª•ng g√¨ -------------
      function speakText(text) {
        if (!text) return;
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "en-US";
        u.rate = parseFloat(document.getElementById("speedSlider").value);

        u.onstart = () => {
          updateStatus("Speaking...");
          document.getElementById("speakBtn").className = "btn btn-speaking";
        };
        u.onend = () => {
          updateStatus("Ready");
          document.getElementById("speakBtn").className = "btn btn-success";
        };

        window.speechSynthesis.speak(u);
      }

      async function translateText(text) {
        const trimmed = text.trim();
        if (!trimmed) return;

        updateStatus("Translating...");

        try {
          const resp = await fetch("/translate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: trimmed }),
          });

          const data = await resp.json();
          const translation = data.translation;

          if (!translation) {
            updateStatus("Ready");
            return;
          }

          // Ch·ªâ hi·ªÉn th·ªã & l∆∞u ƒëo·∫°n ti·∫øng Anh m·ªõi nh·∫•t
          lastTranslation = translation;
          document.getElementById("outputText").textContent = translation;
          updateStatus("Ready");

          // ƒê·ªçc ƒë√∫ng ƒëo·∫°n m·ªõi ƒë√≥, KH√îNG d√≠nh g√¨ v·ªõi ƒëo·∫°n c≈©
          if (document.getElementById("autoSpeak").checked) {
            speakText(translation);
          }
        } catch (err) {
          console.error("Translate error:", err);
          updateStatus("Ready");
        }
      }

      function handleSpeak() {
        if (!lastTranslation) return;
        // B·∫•m n√∫t Speak -> ch·ªâ ƒë·ªçc l·∫°i CHUNK ti·∫øng Anh m·ªõi nh·∫•t
        speakText(lastTranslation);
      }

      function handleStop() {
        window.speechSynthesis.cancel();
        updateStatus("Ready");
        document.getElementById("speakBtn").className = "btn btn-success";
      }

      // ================= Typing =================
      document.getElementById("inputText").addEventListener("input", (e) => {
        if (isFromVoice) return;
        const currentVi = e.target.value;
        const trimmed = currentVi.trim();
        clearTimeout(typingTimer);

        if (!trimmed) {
          document.getElementById("outputText").textContent =
            "Translation will appear here...";
          lastTranslation = "";
          prevInputVi = "";
          updateStatus("Ready");
          return;
        }

        updateStatus("Typing...");
        typingTimer = setTimeout(() => {
          // N·∫øu ng∆∞·ªùi d√πng g√µ ti·∫øng Anh -> ƒë·ªçc lu√¥n ti·∫øng Anh (kh√¥ng d·ªãch)
          if (isEnglishSentence(trimmed)) {
            lastTranslation = trimmed;
            document.getElementById("outputText").textContent = trimmed;
            // ƒë·ªçc ƒë√∫ng ƒëo·∫°n ng∆∞·ªùi ta ƒëang g√µ (chunk hi·ªán t·∫°i)
            speakText(trimmed);
          } else {
            // Ng∆∞·ªùi d√πng g√µ ti·∫øng Vi·ªát
            // L·∫•y ph·∫ßn m·ªõi th√™m so v·ªõi l·∫ßn tr∆∞·ªõc (suffix theo prefix chung)
            const lcp = longestCommonPrefixLen(prevInputVi, currentVi);
            let newVi = currentVi.slice(lcp).trim();
            prevInputVi = currentVi;

            // N·∫øu kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c ph·∫ßn m·ªõi (ho·∫∑c user s·ª≠a lung tung) -> fallback: d·ªãch to√†n b·ªô
            if (!newVi) {
              newVi = trimmed;
            }

            translateText(newVi);
          }
        }, 700);
      });

      // ================= Voice =================
      function initRecognition() {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) {
          alert("Browser kh√¥ng h·ªó tr·ª£ Web Speech API (h√£y d√πng Chrome).");
          return null;
        }

        const rec = new SR();
        rec.lang = "vi-VN";
        rec.continuous = true;
        rec.interimResults = true;

        rec.onstart = () => {
          updateStatus("Listening...");
          document.getElementById("voiceBtn").textContent = "‚èπÔ∏è Stop Listening";
        };

        rec.onend = () => {
          if (isListening) {
            try {
              rec.start();
            } catch (e) {
              console.error("Restart error:", e);
              isListening = false;
              updateStatus("Ready");
              document.getElementById("voiceBtn").textContent =
                "üé§ Start Listening";
            }
          } else {
            updateStatus("Ready");
            document.getElementById("voiceBtn").textContent =
              "üé§ Start Listening";
          }
        };

        rec.onerror = (e) => {
          console.error("WS error:", e);
        };

        rec.onresult = (e) => {
          let interim = "";

          for (let i = e.resultIndex; i < e.results.length; i++) {
            const res = e.results[i];
            const txt = res[0].transcript;

            if (res.isFinal) {
              const seg = txt.trim();
              if (!seg) continue;
              fullVoiceTranscript = (fullVoiceTranscript + " " + seg).trim();
            } else {
              interim += txt;
            }
          }

          const display = (fullVoiceTranscript + " " + interim).trim();
          document.getElementById("detectedText").textContent =
            display || "‚Äî";

          // sau m·ªói result -> reset timer, n·∫øu 1s kh√¥ng c√≥ result m·ªõi -> coi l√† ng∆∞ng c√¢u
          if (voiceSilenceTimer) clearTimeout(voiceSilenceTimer);
          voiceSilenceTimer = setTimeout(onVoiceSilence, 500);
        };

        return rec;
      }

      // User im kho·∫£ng 1s -> l·∫•y ph·∫ßn m·ªõi so v·ªõi l·∫ßn tr∆∞·ªõc
      function onVoiceSilence() {
        const newText = fullVoiceTranscript
          .slice(processedVoiceTranscript.length)
          .trim();
        if (!newText) return;

        processedVoiceTranscript = fullVoiceTranscript;
        handleVoiceChunk(newText);
      }

      function handleVoiceChunk(text) {
        const chunk = text.trim();
        if (!chunk) return;
        if (chunk.length < 2) return;

        // ƒê∆∞a chunk v√†o textarea (kh√¥ng k√≠ch ho·∫°t logic typing)
        isFromVoice = true;
        const inputEl = document.getElementById("inputText");
        inputEl.value = (inputEl.value + " " + chunk).trim();
        setTimeout(() => {
          isFromVoice = false;
        }, 50);

        if (isEnglishSentence(chunk)) {
          // N√≥i ti·∫øng Anh -> kh√¥ng d·ªãch, ƒë·ªçc nguy√™n chunk n√†y
          lastTranslation = chunk;
          document.getElementById("outputText").textContent = chunk;
          speakText(chunk);
        } else {
          // N√≥i ti·∫øng Vi·ªát -> d·ªãch ƒë√∫ng chunk ƒë√≥ -> ƒë·ªçc chunk ti·∫øng Anh
          translateText(chunk);
        }
      }

      function toggleVoiceInput() {
        if (!recognition) {
          recognition = initRecognition();
          if (!recognition) return;
        }

        if (!isListening) {
          isListening = true;

          fullVoiceTranscript = "";
          processedVoiceTranscript = "";
          if (voiceSilenceTimer) {
            clearTimeout(voiceSilenceTimer);
            voiceSilenceTimer = null;
          }

          document.getElementById("detectedText").textContent = "‚Äî";
          recognition.start();
        } else {
          isListening = false;
          try {
            recognition.stop();
          } catch (e) {
            console.error("Stop error:", e);
          }
          if (voiceSilenceTimer) {
            clearTimeout(voiceSilenceTimer);
            voiceSilenceTimer = null;
          }
        }
      }
    </script>
  </body>
</html>
